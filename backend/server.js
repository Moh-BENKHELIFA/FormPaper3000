const express = require('express');
const cors = require('cors');
const multer = require('multer');
const axios = require('axios');
const path = require('path');
const fs = require('fs');
const { spawn } = require('child_process');
const { promisify } = require('util');

// Import de la base de donn√©es
const { paperDB, READING_STATUS } = require('./src/database');

const app = express();
const PORT = 5324;

// Middleware
app.use(cors());
app.use(express.json());

// Configuration multer pour l'upload de fichiers
const storage = multer.diskStorage({
  destination: (req, file, cb) => {
    const uploadDir = 'uploads/';
    if (!fs.existsSync(uploadDir)) {
      fs.mkdirSync(uploadDir, { recursive: true });
    }
    cb(null, uploadDir);
  },
  filename: (req, file, cb) => {
    cb(null, Date.now() + '-' + file.originalname);
  }
});

const upload = multer({ 
  storage: storage,
  limits: {
    fileSize: 10 * 1024 * 1024 // 10MB limit
  }
});

// Initialisation de la base de donn√©es au d√©marrage
async function initializeApp() {
  try {
    console.log('üîó Connexion √† la base de donn√©es...');
    await paperDB.connect();
    console.log('‚úÖ Base de donn√©es connect√©e avec succ√®s');
  } catch (error) {
    console.error('‚ùå Erreur lors de l\'initialisation de la base:', error);
    process.exit(1);
  }
}

// Fonction pour extraire les images d'un PDF avec Python
async function extractImagesFromPdf(pdfPath, outputFolder) {
  return new Promise((resolve, reject) => {
    const scriptPath = path.join(__dirname, 'scripts', 'extract_images.py');
    
    if (!fs.existsSync(scriptPath)) {
      reject(new Error(`Script Python non trouv√©: ${scriptPath}`));
      return;
    }

    console.log(`Extraction des images du PDF: ${pdfPath}`);
    console.log(`Dossier de sortie: ${outputFolder}`);

    const pythonProcess = spawn('python', [scriptPath, pdfPath, outputFolder]);
    
    let output = '';
    let errorOutput = '';

    pythonProcess.stdout.on('data', (data) => {
      output += data.toString();
    });

    pythonProcess.stderr.on('data', (data) => {
      errorOutput += data.toString();
    });

    pythonProcess.on('close', (code) => {
      console.log(`Script d'extraction d'images termin√© avec le code: ${code}`);
      console.log(`Sortie stderr: ${errorOutput}`);

      if (code === 0 && output.trim()) {
        try {
          const extractedImages = JSON.parse(output.trim());
          console.log(`${extractedImages.length} images extraites`);
          resolve(extractedImages);
        } catch (parseError) {
          console.error('Erreur lors du parsing JSON:', parseError);
          resolve([]);
        }
      } else {
        console.log('Aucune image extraite du PDF');
        resolve([]);
      }
    });

    pythonProcess.on('error', (error) => {
      console.error('Erreur lors de l\'extraction des images:', error.message);
      reject(error);
    });
  });
}

async function extractDoiFromPdf(pdfPath) {
  return new Promise((resolve, reject) => {
    const scriptPath = path.join(__dirname, 'scripts', 'extract_doi.py');
    
    if (!fs.existsSync(scriptPath)) {
      reject(new Error(`Script Python non trouv√©: ${scriptPath}`));
      return;
    }

    console.log(`Ex√©cution du script Python: ${scriptPath}`);
    console.log(`Fichier PDF √† analyser: ${pdfPath}`);

    const pythonProcess = spawn('python', [scriptPath, pdfPath]);
    
    let output = '';
    let errorOutput = '';

    pythonProcess.stdout.on('data', (data) => {
      output += data.toString();
    });

    pythonProcess.stderr.on('data', (data) => {
      errorOutput += data.toString();
    });

    pythonProcess.on('close', (code) => {
      console.log(`Script Python termin√© avec le code: ${code}`);
      console.log(`Sortie stderr: ${errorOutput}`);

      if (code === 0 && output.trim()) {
        const doi = output.trim();
        console.log(`DOI extrait avec succ√®s: ${doi}`);
        resolve(doi);
      } else {
        console.log('Aucun DOI trouv√© dans le PDF');
        resolve(null);
      }
    });

    pythonProcess.on('error', (error) => {
      console.error('Erreur lors de l\'ex√©cution de Python:', error.message);
      
      if (error.code === 'ENOENT') {
        reject(new Error('Python n\'est pas install√© ou n\'est pas dans le PATH. Veuillez installer Python et PyMuPDF (pip install PyMuPDF).'));
      } else {
        reject(error);
      }
    });
  });
}

// Route de test de sant√©
app.get('/api/health', (req, res) => {
  res.json({ 
    status: 'OK', 
    message: 'Backend fonctionnel',
    database: paperDB.isConnectedToDB() ? 'Connected' : 'Disconnected'
  });
});

// R√©cup√©rer les m√©tadonn√©es depuis un DOI
app.post('/api/papers/metadata-from-doi', async (req, res) => {
  try {
    const { doi } = req.body;
    
    if (!doi) {
      return res.status(400).json({ error: 'DOI requis' });
    }

    console.log(`R√©cup√©ration des m√©tadonn√©es pour DOI: ${doi}`);

    const crossrefUrl = `https://api.crossref.org/works/${doi}`;
    
    const response = await axios.get(crossrefUrl, {
      headers: {
        'Accept': 'application/json'
      },
      timeout: 10000
    });

    const work = response.data.message;
    
    const authors = work.author 
      ? work.author.map(a => `${a.given || ''} ${a.family || ''}`.trim())
      : ['Auteur inconnu'];

    const metadata = {
      title: work.title ? work.title[0] : 'Titre non disponible',
      authors: authors.join(', '),
      doi: work.DOI || doi,
      conference: work['container-title'] ? work['container-title'][0] : '',
      publication_date: work.published 
        ? `${work.published['date-parts'][0][0]}-${String(work.published['date-parts'][0][1] || 1).padStart(2, '0')}-${String(work.published['date-parts'][0][2] || 1).padStart(2, '0')}`
        : new Date().toISOString().split('T')[0],
      url: work.URL || `https://doi.org/${doi}`
    };

    console.log('M√©tadonn√©es r√©cup√©r√©es:', metadata);
    res.json(metadata);

  } catch (error) {
    console.error('Erreur lors de la r√©cup√©ration DOI:', error.message);
    
    if (error.response?.status === 404) {
      return res.status(404).json({ 
        error: 'DOI non trouv√©',
        message: 'Le DOI sp√©cifi√© n\'existe pas dans la base Crossref'
      });
    }
    
    if (error.code === 'ECONNABORTED') {
      return res.status(408).json({ 
        error: 'Timeout',
        message: 'La requ√™te a expir√©. V√©rifiez votre connexion internet.'
      });
    }

    res.status(500).json({ 
      error: 'Erreur lors de la r√©cup√©ration des m√©tadonn√©es',
      message: error.message
    });
  }
});

// Extraire les images d'un PDF
app.post('/api/papers/extract-images', upload.single('pdf'), async (req, res) => {
  try {
    if (!req.file) {
      return res.status(400).json({ error: 'Fichier PDF requis' });
    }

    console.log(`Extraction des images du PDF: ${req.file.filename}`);

    const imageFolder = path.join('uploads', 'images', `pdf_${Date.now()}`);
    
    const extractedImages = await extractImagesFromPdf(req.file.path, imageFolder);
    
    fs.unlinkSync(req.file.path);

    const imagesForFrontend = extractedImages.map(img => ({
      ...img,
      url: `http://localhost:${PORT}/${img.path.replace(/\\/g, '/')}`
    }));

    console.log(`Images extraites et converties:`, imagesForFrontend);
    res.json({ images: imagesForFrontend });

  } catch (error) {
    console.error('Erreur lors de l\'extraction des images:', error.message);
    
    if (req.file && fs.existsSync(req.file.path)) {
      fs.unlinkSync(req.file.path);
    }

    res.status(500).json({ 
      error: 'Erreur lors de l\'extraction des images du PDF',
      message: error.message
    });
  }
});

// Extraire les m√©tadonn√©es depuis un PDF
app.post('/api/papers/extract-from-pdf', upload.single('pdf'), async (req, res) => {
  try {
    if (!req.file) {
      return res.status(400).json({ error: 'Fichier PDF requis' });
    }

    console.log(`Extraction des m√©tadonn√©es du PDF: ${req.file.filename}`);

    const doi = await extractDoiFromPdf(req.file.path);
    
    if (!doi) {
      fs.unlinkSync(req.file.path);
      return res.status(404).json({ 
        error: 'DOI non trouv√© dans le PDF',
        message: 'Aucun DOI n\'a pu √™tre extrait de ce fichier PDF'
      });
    }

    console.log(`DOI extrait du PDF: ${doi}`);

    try {
      const crossrefUrl = `https://api.crossref.org/works/${doi}`;
      
      const response = await axios.get(crossrefUrl, {
        headers: {
          'Accept': 'application/json'
        },
        timeout: 10000
      });

      const work = response.data.message;
      
      const authors = work.author 
        ? work.author.map(a => `${a.given || ''} ${a.family || ''}`.trim())
        : ['Auteur inconnu'];

      const metadata = {
        title: work.title ? work.title[0] : 'Titre non disponible',
        authors: authors.join(', '),
        doi: work.DOI || doi,
        conference: work['container-title'] ? work['container-title'][0] : '',
        publication_date: work.published 
          ? `${work.published['date-parts'][0][0]}-${String(work.published['date-parts'][0][1] || 1).padStart(2, '0')}-${String(work.published['date-parts'][0][2] || 1).padStart(2, '0')}`
          : new Date().toISOString().split('T')[0],
        url: work.URL || `https://doi.org/${doi}`
      };

      fs.unlinkSync(req.file.path);

      console.log('M√©tadonn√©es r√©cup√©r√©es via DOI extrait:', metadata);
      res.json(metadata);

    } catch (crossrefError) {
      console.error('Erreur Crossref:', crossrefError.message);
      
      const fallbackMetadata = {
        title: `Titre extrait de ${req.file.originalname}`,
        authors: 'Auteurs non trouv√©s',
        doi: doi,
        conference: 'Conf√©rence non trouv√©e',
        publication_date: new Date().toISOString().split('T')[0],
        url: `https://doi.org/${doi}`
      };

      fs.unlinkSync(req.file.path);
      res.json(fallbackMetadata);
    }

  } catch (error) {
    console.error('Erreur lors de l\'extraction PDF:', error.message);
    
    if (req.file && fs.existsSync(req.file.path)) {
      fs.unlinkSync(req.file.path);
    }

    res.status(500).json({ 
      error: 'Erreur lors de l\'extraction des m√©tadonn√©es PDF',
      message: error.message
    });
  }
});

// Sauvegarder un paper dans la base de donn√©es
app.post('/api/papers', upload.single('pdf'), async (req, res) => {
  try {
    console.log('üî• R√©ception d\'une demande de sauvegarde de paper');
    console.log('Body:', req.body);
    console.log('File:', req.file ? req.file.originalname : 'Aucun fichier');

    // Extraire les donn√©es du formulaire
    const paperData = {
      title: req.body.title,
      authors: req.body.authors,
      publication_date: req.body.publication_date,
      conference: req.body.conference || null,
      conference_abbreviation: req.body.conference_abbreviation || null,
      reading_status: req.body.reading_status || READING_STATUS.NON_LU,
      doi: req.body.doi,
      url: req.body.url,
      image: req.body.image || null
    };

    console.log('üìã Donn√©es du paper √† sauvegarder:', paperData);

    // Validation basique
    if (!paperData.title || !paperData.authors || !paperData.doi) {
      return res.status(400).json({ 
        error: 'Donn√©es manquantes',
        message: 'Titre, auteurs et DOI sont requis'
      });
    }

    // G√©rer les cat√©gories si pr√©sentes
    let categories = [];
    if (req.body.categories) {
      try {
        categories = typeof req.body.categories === 'string' 
          ? JSON.parse(req.body.categories) 
          : req.body.categories;
        console.log('üè∑Ô∏è Cat√©gories re√ßues:', categories);
      } catch (error) {
        console.warn('‚ö†Ô∏è Erreur parsing cat√©gories:', error.message);
      }
    }

    // Pr√©parer les donn√©es pour les fichiers
    let pdfBuffer = null;
    let pdfName = null;
    let extractedImages = [];

    // Si un PDF est fourni
    if (req.file) {
      pdfBuffer = fs.readFileSync(req.file.path);
      pdfName = req.file.originalname;
      console.log(`üìÑ PDF d√©tect√©: ${pdfName} (${pdfBuffer.length} bytes)`);
      
      // Nettoyer le fichier temporaire
      fs.unlinkSync(req.file.path);
    }

    // Traiter les images extraites si pr√©sentes
    if (req.body.extractedImages) {
      try {
        extractedImages = JSON.parse(req.body.extractedImages);
        console.log(`üñºÔ∏è ${extractedImages.length} images extraites √† traiter`);
      } catch (error) {
        console.warn('‚ö†Ô∏è Erreur parsing images extraites:', error.message);
      }
    }

    // Sauvegarder dans la base de donn√©es avec cat√©gories
    console.log('üíæ Sauvegarde en cours...');
    const savedPaper = await paperDB.createCompletePaper(
      paperData,
      pdfBuffer,
      pdfName,
      extractedImages,
      categories, // Passer les cat√©gories
      null // Description (pour l'instant null)
    );

    console.log(`‚úÖ Paper sauvegard√© avec succ√®s! ID: ${savedPaper.id}`);

    // Statistiques
    const stats = await paperDB.getStats();
    console.log(`üìä Total papers en base: ${stats.totalPapers}`);

    res.status(201).json({ 
      success: true,
      id: savedPaper.id, 
      message: 'Paper sauvegard√© avec succ√®s',
      paper: savedPaper,
      stats: stats
    });

  } catch (error) {
    console.error('‚ùå Erreur lors de la sauvegarde:', error);
    
    // Nettoyer le fichier temporaire en cas d'erreur
    if (req.file && fs.existsSync(req.file.path)) {
      fs.unlinkSync(req.file.path);
    }

    // Gestion des erreurs sp√©cifiques
    if (error.message.includes('UNIQUE constraint failed')) {
      return res.status(409).json({ 
        error: 'DOI d√©j√† existant',
        message: 'Ce DOI existe d√©j√† dans la base de donn√©es'
      });
    }

    res.status(500).json({ 
      error: 'Erreur lors de la sauvegarde',
      message: error.message
    });
  }
});

// R√©cup√©rer tous les papers
app.get('/api/papers', async (req, res) => {
  try {
    console.log('üìñ R√©cup√©ration de tous les papers...');
    
    const papers = await paperDB.papers.getAll();
    console.log(`üìö ${papers.length} papers r√©cup√©r√©s`);

    res.json({
      success: true,
      papers: papers,
      total: papers.length
    });

  } catch (error) {
    console.error('‚ùå Erreur lors de la r√©cup√©ration des papers:', error);
    res.status(500).json({ 
      error: 'Erreur lors de la r√©cup√©ration des papers',
      message: error.message
    });
  }
});

// R√©cup√©rer un paper par ID avec d√©tails
app.get('/api/papers/:id', async (req, res) => {
  try {
    const paperId = parseInt(req.params.id);
    
    if (isNaN(paperId)) {
      return res.status(400).json({ error: 'ID invalide' });
    }

    console.log(`üîç R√©cup√©ration du paper ID: ${paperId}`);
    
    const paper = await paperDB.papers.getByIdWithDetails(paperId);
    
    if (!paper) {
      return res.status(404).json({ 
        error: 'Paper non trouv√©',
        message: `Aucun paper trouv√© avec l'ID ${paperId}`
      });
    }

    console.log(`üìÑ Paper r√©cup√©r√©: ${paper.title}`);
    res.json({
      success: true,
      paper: paper
    });

  } catch (error) {
    console.error('‚ùå Erreur lors de la r√©cup√©ration du paper:', error);
    res.status(500).json({ 
      error: 'Erreur lors de la r√©cup√©ration du paper',
      message: error.message
    });
  }
});

// Mise √† jour d'un paper avec cat√©gories
app.put('/api/papers/:id', async (req, res) => {
  try {
    const paperId = parseInt(req.params.id);
    
    if (isNaN(paperId)) {
      return res.status(400).json({ error: 'ID invalide' });
    }

    console.log(`üîÑ Mise √† jour du paper ID: ${paperId}`);
    console.log('Donn√©es √† mettre √† jour:', req.body);
    
    // S√©parer les cat√©gories des autres donn√©es
    const { categories, ...paperUpdates } = req.body;
    
    // Mettre √† jour les donn√©es du paper
    const updated = await paperDB.papers.update(paperId, paperUpdates);
    
    // G√©rer les cat√©gories si pr√©sentes
    if (categories && Array.isArray(categories)) {
      await paperDB.paperCategories.setPaperCategories(paperId, categories);
    }
    
    // R√©cup√©rer le paper mis √† jour avec d√©tails
    const updatedPaper = await paperDB.papers.getByIdWithDetails(paperId);
    
    if (!updatedPaper) {
      return res.status(404).json({ 
        error: 'Paper non trouv√©',
        message: `Aucun paper trouv√© avec l'ID ${paperId}`
      });
    }

    console.log(`‚úÖ Paper ${paperId} mis √† jour avec succ√®s`);
    res.json({
      success: true,
      paper: updatedPaper,
      message: 'Paper mis √† jour avec succ√®s'
    });

  } catch (error) {
    console.error('‚ùå Erreur lors de la mise √† jour du paper:', error);
    res.status(500).json({ 
      error: 'Erreur lors de la mise √† jour du paper',
      message: error.message
    });
  }
});

// Supprimer un paper
app.delete('/api/papers/:id', async (req, res) => {
  try {
    const paperId = parseInt(req.params.id);
    
    if (isNaN(paperId)) {
      return res.status(400).json({ error: 'ID invalide' });
    }

    console.log(`üóëÔ∏è Suppression du paper ID: ${paperId}`);
    
    const deleted = await paperDB.deleteCompletePaper(paperId);
    
    if (!deleted) {
      return res.status(404).json({ 
        error: 'Paper non trouv√©',
        message: `Aucun paper trouv√© avec l'ID ${paperId}`
      });
    }

    console.log(`‚úÖ Paper ${paperId} supprim√© avec succ√®s`);
    res.json({
      success: true,
      message: 'Paper supprim√© avec succ√®s'
    });

  } catch (error) {
    console.error('‚ùå Erreur lors de la suppression du paper:', error);
    res.status(500).json({ 
      error: 'Erreur lors de la suppression du paper',
      message: error.message
    });
  }
});

// Statistiques de la base
app.get('/api/papers/stats', async (req, res) => {
  try {
    console.log('üìä R√©cup√©ration des statistiques...');
    
    const stats = await paperDB.getStats();
    console.log('üìà Statistiques:', stats);

    res.json({
      success: true,
      stats: stats
    });

  } catch (error) {
    console.error('‚ùå Erreur lors de la r√©cup√©ration des stats:', error);
    res.status(500).json({ 
      error: 'Erreur lors de la r√©cup√©ration des statistiques',
      message: error.message
    });
  }
});

// Gestion des cat√©gories - R√©cup√©rer toutes les cat√©gories
app.get('/api/categories', async (req, res) => {
  try {
    console.log('üè∑Ô∏è R√©cup√©ration des cat√©gories...');
    
    const categories = await paperDB.categories.getAll();
    console.log(`üìù ${categories.length} cat√©gories r√©cup√©r√©es`);

    res.json({
      success: true,
      categories: categories
    });

  } catch (error) {
    console.error('‚ùå Erreur lors de la r√©cup√©ration des cat√©gories:', error);
    res.status(500).json({ 
      error: 'Erreur lors de la r√©cup√©ration des cat√©gories',
      message: error.message
    });
  }
});

// Cr√©er une nouvelle cat√©gorie
app.post('/api/categories', async (req, res) => {
  try {
    const { name } = req.body;
    
    if (!name || !name.trim()) {
      return res.status(400).json({ 
        error: 'Nom de cat√©gorie requis' 
      });
    }

    console.log(`üÜï Cr√©ation de la cat√©gorie: ${name}`);
    
    const categoryId = await paperDB.categories.create(name.trim());
    const category = await paperDB.categories.getById(categoryId);
    console.log(`‚úÖ Cat√©gorie cr√©√©e avec l'ID: ${categoryId}`);

    res.status(201).json({
      success: true,
      id: categoryId,
      category: category,
      message: 'Cat√©gorie cr√©√©e avec succ√®s'
    });

  } catch (error) {
    console.error('‚ùå Erreur lors de la cr√©ation de la cat√©gorie:', error);
    
    if (error.message.includes('UNIQUE constraint failed')) {
      return res.status(409).json({ 
        error: 'Nom de cat√©gorie d√©j√† existant',
        message: 'Cette cat√©gorie existe d√©j√†'
      });
    }

    res.status(500).json({ 
      error: 'Erreur lors de la cr√©ation de la cat√©gorie',
      message: error.message
    });
  }
});

// Supprimer une cat√©gorie
app.delete('/api/categories/:id', async (req, res) => {
  try {
    const categoryId = parseInt(req.params.id);
    
    if (isNaN(categoryId)) {
      return res.status(400).json({ error: 'ID de cat√©gorie invalide' });
    }

    console.log(`üóëÔ∏è Suppression de la cat√©gorie ID: ${categoryId}`);
    
    const deleted = await paperDB.categories.delete(categoryId);
    
    if (!deleted) {
      return res.status(404).json({ 
        error: 'Cat√©gorie non trouv√©e',
        message: `Aucune cat√©gorie trouv√©e avec l'ID ${categoryId}`
      });
    }

    console.log(`‚úÖ Cat√©gorie ${categoryId} supprim√©e avec succ√®s`);
    res.json({
      success: true,
      message: 'Cat√©gorie supprim√©e avec succ√®s'
    });

  } catch (error) {
    console.error('‚ùå Erreur lors de la suppression de la cat√©gorie:', error);
    res.status(500).json({ 
      error: 'Erreur lors de la suppression de la cat√©gorie',
      message: error.message
    });
  }
});

// Upload d'image (gard√© pour compatibilit√©)
app.post('/api/papers/upload-image', upload.single('image'), (req, res) => {
  try {
    if (!req.file) {
      return res.status(400).json({ error: 'Fichier image requis' });
    }

    const imageUrl = `http://localhost:${PORT}/uploads/${req.file.filename}`;
    
    console.log(`üñºÔ∏è Image upload√©e: ${imageUrl}`);
    res.json({ imageUrl });

  } catch (error) {
    console.error('‚ùå Erreur lors de l\'upload:', error.message);
    res.status(500).json({ 
      error: 'Erreur lors de l\'upload de l\'image',
      message: error.message
    });
  }
});

// Servir les fichiers statiques
app.use('/uploads', express.static('uploads'));
app.use('/MyPapers', express.static('MyPapers'));

// Route par d√©faut
app.get('/', (req, res) => {
  res.json({ 
    message: 'API Paper Manager avec SQLite',
    version: '3.0.0',
    database: paperDB.isConnectedToDB() ? 'Connected' : 'Disconnected',
    endpoints: [
      'GET /api/health',
      'POST /api/papers/metadata-from-doi',
      'POST /api/papers/extract-images',
      'POST /api/papers/extract-from-pdf',
      'POST /api/papers (Save to database with categories)',
      'GET /api/papers (Get all papers)',
      'GET /api/papers/:id (Get paper by ID)',
      'PUT /api/papers/:id (Update paper with categories)',
      'DELETE /api/papers/:id (Delete paper)',
      'GET /api/papers/stats (Get statistics)',
      'GET /api/categories (Get all categories)',
      'POST /api/categories (Create category)',
      'DELETE /api/categories/:id (Delete category)',
      'POST /api/papers/upload-image (Upload image)'
    ]
  });
});

// D√©marrage du serveur avec initialisation de la base
async function startServer() {
  try {
    await initializeApp();
    
    app.listen(PORT, () => {
      console.log(`üöÄ Serveur d√©marr√© sur http://localhost:${PORT}`);
      console.log(`üìä API disponible sur http://localhost:${PORT}/api`);
      console.log(`‚ù§Ô∏è Health check: http://localhost:${PORT}/api/health`);
      console.log(`üíæ Base de donn√©es SQLite: ${paperDB.isConnectedToDB() ? 'Connect√©e' : 'D√©connect√©e'}`);
      console.log(`üìà Statistiques: http://localhost:${PORT}/api/papers/stats`);
      console.log(`üè∑Ô∏è Cat√©gories: http://localhost:${PORT}/api/categories`);
    });
  } catch (error) {
    console.error('‚ùå Erreur lors du d√©marrage:', error);
    process.exit(1);
  }
}

// Gestion des arr√™ts propres
process.on('SIGINT', async () => {
  console.log('üõë Arr√™t du serveur...');
  try {
    await paperDB.disconnect();
    console.log('‚úÖ Base de donn√©es ferm√©e proprement');
    process.exit(0);
  } catch (error) {
    console.error('‚ùå Erreur lors de la fermeture:', error);
    process.exit(1);
  }
});

process.on('uncaughtException', (error) => {
  console.error('‚ùå Erreur non captur√©e:', error);
});

process.on('unhandledRejection', (reason, promise) => {
  console.error('‚ùå Promesse rejet√©e non g√©r√©e:', reason);
});

// D√©marrer l'application
startServer();